<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyrepo Synthesis: Synthesis Coding Across Multiple Repositories with Claude Code in Visual Studio Code — Synthesis Coding</title>
    <meta name="description" content="I wrote this blog post for Software Engineers, Architects, and Technical Leads. It is code-heavy and implementation-focused. This weekend I was working across three repositories simultaneously in Visual Studio Code. I worked on RagBot — a multi-LLM chatbot that lets you switch between OpenAI, Anthro">
    <meta name="keywords" content="synthesis coding, synthesis engineering, AI-assisted development, software engineering">

    <!-- Canonical URL pointing to WordPress -->
    <link rel="canonical" href="https://rajiv.com/blog/2025/11/30/polyrepo-synthesis-synthesis-coding-across-multiple-repositories-with-claude-code-in-visual-studio-code/">

    <!-- Open Graph -->
    <meta property="og:title" content="Polyrepo Synthesis: Synthesis Coding Across Multiple Repositories with Claude Code in Visual Studio Code">
    <meta property="og:description" content="I wrote this blog post for Software Engineers, Architects, and Technical Leads. It is code-heavy and implementation-focused. This weekend I was working across three repositories simultaneously in Visual Studio Code. I worked on RagBot — a multi-LLM chatbot that lets you switch between OpenAI, Anthro">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://synthesiscoding.com/articles/polyrepo-synthesis-synthesis-coding-across-multiple-repositories-with-claude-code-in-visual-studio-code/">
    <meta property="og:image" content="https://synthesiscoding.com/assets/og-image.jpg">
    <meta property="og:site_name" content="Synthesis Coding">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Polyrepo Synthesis: Synthesis Coding Across Multiple Repositories with Claude Code in Visual Studio Code">
    <meta name="twitter:description" content="I wrote this blog post for Software Engineers, Architects, and Technical Leads. It is code-heavy and implementation-focused. This weekend I was working across three repositories simultaneously in Visual Studio Code. I worked on RagBot — a multi-LLM chatbot that lets you switch between OpenAI, Anthro">

    <!-- RSS Feed -->
    <link rel="alternate" type="application/rss+xml" title="Synthesis Coding RSS Feed" href="/feed.xml">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,400;0,6..72,500;0,6..72,600;1,6..72,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Prism.js syntax highlighting (Tomorrow Night theme) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet">

    <style>
        :root {
            --black: #0a0a0a;
            --dark: #1a1a1a;
            --gray-dark: #3a3a3a;
            --gray: #666;
            --gray-light: #999;
            --gray-lighter: #e5e5e5;
            --white: #fafafa;
            --cream: #f5f4f0;
            --accent: #2a2a2a;

            --font-serif: 'Newsreader', Georgia, serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;

            --max-width: 720px;
            --wide-width: 960px;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        html {
            font-size: 18px;
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-serif);
            font-size: 1rem;
            line-height: 1.7;
            color: var(--dark);
            background: var(--white);
            -webkit-font-smoothing: antialiased;
        }

        /* Header */
        header {
            padding: 2rem;
            text-align: center;
            border-bottom: 1px solid var(--gray-lighter);
        }

        .logo {
            max-width: 240px;
            width: 100%;
            height: auto;
        }

        /* Nav */
        nav {
            position: sticky;
            top: 0;
            background: var(--white);
            border-bottom: 1px solid var(--gray-lighter);
            padding: 0.75rem 2rem;
            z-index: 100;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        nav a {
            text-decoration: none;
            color: var(--gray);
        }

        nav a:hover {
            color: var(--black);
        }

        /* Main content */
        main {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Article header */
        .article-header {
            padding: 3rem 0 2rem;
            border-bottom: 1px solid var(--gray-lighter);
            margin-bottom: 2rem;
        }

        .article-header h1 {
            font-size: 2rem;
            font-weight: 500;
            line-height: 1.3;
            color: var(--black);
            margin: 0 0 1rem;
        }

        .article-meta {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--gray-light);
            letter-spacing: 0.02em;
        }

        .article-meta .separator {
            margin: 0 0.5rem;
            color: var(--gray-lighter);
        }

        .category-badge {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-decoration: none;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            background: color-mix(in srgb, var(--cat-color, #6b7280) 15%, transparent);
            color: var(--cat-color, #6b7280);
            border: 1px solid color-mix(in srgb, var(--cat-color, #6b7280) 30%, transparent);
            transition: all 0.2s;
        }

        .category-badge:hover {
            background: color-mix(in srgb, var(--cat-color, #6b7280) 25%, transparent);
        }

        .canonical-notice {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: var(--cream);
            font-size: 0.85rem;
            color: var(--gray);
            border-left: 3px solid var(--gray-lighter);
        }

        .canonical-notice a {
            color: var(--dark);
        }

        /* Tags */
        .article-tags {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--gray-lighter);
        }

        .article-tags-label {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--gray-light);
            margin-bottom: 0.75rem;
        }

        .article-tags .tag {
            display: inline-block;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            background: var(--cream);
            color: var(--gray);
            padding: 0.25rem 0.6rem;
            margin: 0 0.4rem 0.4rem 0;
            border-radius: 3px;
            text-decoration: none;
            transition: all 0.2s;
        }

        .article-tags a.tag:hover {
            background: var(--gray-lighter);
            color: var(--dark);
        }

        /* Related articles */
        .related-articles {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--gray-lighter);
        }

        .related-articles h2 {
            font-size: 1.25rem;
            font-weight: 500;
            margin: 0 0 1.25rem;
            color: var(--black);
        }

        .related-grid {
            display: grid;
            gap: 1rem;
        }

        .related-card {
            display: block;
            padding: 1rem 1.25rem;
            background: var(--cream);
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.2s;
        }

        .related-card:hover {
            background: var(--gray-lighter);
        }

        .related-title {
            display: block;
            font-weight: 500;
            color: var(--dark);
            margin-bottom: 0.25rem;
            line-height: 1.4;
        }

        .related-meta {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--gray-light);
        }

        /* Article content */
        .article-content {
            padding: 2rem 0 3rem;
        }

        .article-content h2 {
            font-size: 1.5rem;
            font-weight: 500;
            line-height: 1.3;
            color: var(--black);
            margin: 2.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--black);
            display: inline-block;
        }

        .article-content h3 {
            font-size: 1.2rem;
            font-weight: 500;
            line-height: 1.3;
            color: var(--black);
            margin: 2rem 0 0.75rem;
        }

        .article-content h4 {
            font-size: 1.05rem;
            font-weight: 600;
            line-height: 1.3;
            color: var(--black);
            margin: 1.5rem 0 0.5rem;
        }

        .article-content p {
            margin: 0 0 1.25rem;
        }

        .article-content a {
            color: var(--dark);
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-thickness: 1px;
            transition: color 0.2s;
        }

        .article-content a:hover {
            color: var(--gray);
        }

        .article-content ul,
        .article-content ol {
            margin: 0 0 1.25rem;
            padding-left: 1.5rem;
        }

        .article-content li {
            margin-bottom: 0.5rem;
        }

        .article-content li strong {
            font-weight: 600;
        }

        .article-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--cream);
            border-left: 3px solid var(--black);
            font-style: italic;
        }

        .article-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Inline code */
        .article-content code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background: var(--cream);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            color: #c7254e;
        }

        /* Code blocks */
        .article-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: #2d2d2d;
            color: #e0e0e0;
            overflow-x: auto;
            border-radius: 6px;
            border: 1px solid #444;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .article-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: inherit;
        }

        /* Prism toolbar styling */
        div.code-toolbar > .toolbar {
            opacity: 1;
        }

        div.code-toolbar > .toolbar > .toolbar-item > button,
        div.code-toolbar > .toolbar > .toolbar-item > span {
            background: #444;
            color: #ccc;
            padding: 0.35rem 0.6rem;
            font-size: 0.7rem;
            border-radius: 3px;
            font-family: var(--font-mono);
        }

        div.code-toolbar > .toolbar > .toolbar-item > button:hover {
            background: #555;
            color: #fff;
        }

        /* Language label in toolbar */
        .toolbar-item span[data-label]::before {
            content: attr(data-label);
        }

        .article-content hr {
            border: none;
            border-top: 1px solid var(--gray-lighter);
            margin: 2.5rem 0;
        }

        .article-content em {
            font-style: italic;
        }

        .article-content strong {
            font-weight: 600;
        }

        /* Footer */
        footer {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 3rem 2rem 4rem;
            text-align: center;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid var(--gray-lighter);
        }

        footer p {
            margin: 0 0 0.75rem;
        }

        footer a {
            color: var(--dark);
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-thickness: 1px;
        }

        .cc0 {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--gray-light);
            letter-spacing: 0.02em;
        }

        .built-with {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--gray-light);
            margin-top: 1.5rem;
        }

        .built-with a {
            color: var(--gray);
        }

        /* Responsive */
        @media (max-width: 640px) {
            html {
                font-size: 16px;
            }

            header {
                padding: 1.5rem;
            }

            .logo {
                max-width: 200px;
            }

            main {
                padding: 0 1.5rem;
            }

            .article-header {
                padding: 2rem 0 1.5rem;
            }

            .article-header h1 {
                font-size: 1.6rem;
            }

            nav ul {
                gap: 1rem;
            }
        }

        /* Print styles */
        @media print {
            nav {
                display: none;
            }

            header {
                border-bottom: none;
            }

            .canonical-notice {
                display: none;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="/">
            <img src="/assets/logo.webp" alt="Synthesis Coding" class="logo">
        </a>
    </header>

    <nav>
        <ul>
            <li><a href="/#what">What</a></li>
            <li><a href="/#principles">Principles</a></li>
            <li><a href="/#when">When to Use</a></li>
            <li><a href="/articles/">Articles</a></li>
        </ul>
    </nav>

    <main>
        <article>
            <div class="article-header">
                <h1>Polyrepo Synthesis: Synthesis Coding Across Multiple Repositories with Claude Code in Visual Studio Code</h1>
                <div class="article-meta">
                    <time datetime="2025-11-30">November 29, 2025</time>
                    <span class="separator">·</span>
                    <span>12 min read</span>
                    <span class="separator">·</span>
                    <a href="/articles/category/advanced-patterns/" class="category-badge" style="--cat-color: #dc2626">Advanced patterns</a>
                </div>
            </div>

            <div class="article-content">
                <p>I wrote this blog post for Software Engineers, Architects, and Technical Leads. It is code-heavy and implementation-focused.</p>
<p>This weekend I was working across three repositories simultaneously in Visual Studio Code. I worked on <a href="https://ragbot.ai">RagBot</a> — a multi-LLM chatbot that lets you switch between OpenAI, Anthropic, Google, and other providers while maintaining conversation history and custom personas — alongside its successor <a href="https://ragenie.ai">RaGenie</a>, an agentic AI assistant designed to augment human capabilities through retrieval-augmented generation. Both products consume shared data from a third repository called ragbot-data: workspace configurations, custom instructions, knowledge bases.</p>
<p>Claude Code understood something that would have been invisible in a single-repo context: a schema change in ragbot-data would affect both products differently. RagBot reads workspace configurations directly from the filesystem. RaGenie mounts the same data read-only via Docker and re-indexes it into a vector database. Same source, different consumption patterns, different implications for each product.</p>
<p>This is fundamentally different from single-repo development. And it demands its own patterns.</p>
<h2>The multi-repository reality</h2>
<p>Most production software lives across multiple repositories. Look around your organization:</p>
<p><strong>Frontend + Backend + Shared Types</strong> — The classic web application split. TypeScript interfaces defined once, consumed in two places, with deployment pipelines that need coordination.</p>
<p><strong>Application code + Shared data/config</strong> — Products that read from a central source of configurations, knowledge bases, or datasets. My RagBot/RaGenie/ragbot-data setup follows this pattern: two applications consuming one authoritative data source.</p>
<p><strong>Multiple related products</strong> — Platform teams maintaining products that share infrastructure, authentication, or data models. Changes ripple across boundaries.</p>
<p><strong>Microservices architectures</strong> — Each service in its own repository, with shared contracts, API definitions, and deployment orchestration spanning the boundaries.</p>
<p><strong>Notebooks + Production code + Data</strong> — Data science workflows where Jupyter exploration eventually becomes production pipelines, with model artifacts and evaluation datasets living separately.</p>
<p><strong>Infrastructure-as-code + Application repos</strong> — DevOps patterns where Terraform or Pulumi lives separately from the applications they deploy.</p>
<p><strong>Monorepo-to-polyrepo migrations</strong> — Organizations scaling beyond a single repository, splitting by team or domain while maintaining cross-repo dependencies.</p>
<p>The common thread: context fragmentation and the need for consistency across systems that don’t share a git history.</p>
<h2>Introducing Polyrepo Synthesis</h2>
<p><strong>Polyrepo Synthesis</strong> is the practice of applying <a href="/articles/the-synthesis-engineering-framework-how-organizations-build-production-software-with-ai/">synthesis engineering principles</a> across multiple interconnected repositories within a unified development environment.</p>
<p>It’s not a separate methodology — it’s <a href="https://synthesiscoding.com/"><strong>synthesis coding</strong></a> scaled to the architectural reality of modern software systems.</p>
<p>The key principle remains the same: human architectural authority guides everything; AI assists within that unified vision. But “everything” now spans repository boundaries. Your mental model encompasses the entire system, and your AI assistant needs to share that understanding.</p>
<h2>Architectural patterns</h2>
<p>Through my work on multi-repository systems, I’ve identified patterns that recur across organizations:</p>
<h3>Hub-and-spoke (source of truth)</h3>
<p>One repository serves as the authoritative source of data or configuration, with multiple consumer repositories reading from it.</p>
<pre class="language-text"><code class="language-text">┌─────────────────────────────────────────┐
│        ragbot-data/ (private)           │
│    Source of truth for workspaces&#039;      │
│   instructions, runbooks, and datasets  │
└─────────────┬───────────────┬───────────┘
              │               │
              ▼               ▼
      ┌───────────────┐ ┌────────────────────┐
      │    ragbot/    │ │     ragenie/       │
      │  (Chat Bot)   │ │ (Agentic platform) │
      └───────────────┘ └────────────────────┘</code></pre>
<p>The hub is authoritative; spokes consume but don’t modify. This pattern works well when you have shared knowledge, configurations, or datasets that multiple applications need. In my case, ragbot-data contains workspace definitions organized by a WHO/HOW/WHAT framework — identity instructions, procedural runbooks, and reference datasets — that both products consume.</p>
<h3>Product family</h3>
<p>Related products evolving together, sharing patterns but diverging in implementation. RagBot and RaGenie are siblings: RagBot is a Python CLI with Streamlit UI; RaGenie is a FastAPI/React microservices platform. They solve related problems differently, but solutions discovered in one often inform the other.</p>
<p>Cross-pollination happens naturally when Claude Code understands both codebases. A caching pattern that works in RagBot might apply to RaGenie’s API layer. A UI approach in RaGenie’s React frontend might inspire changes to RagBot’s Streamlit interface.</p>
<h3>Stack slice</h3>
<p>Frontend, backend, infrastructure, and data science repositories representing horizontal layers. Feature development cuts vertically across all of them.</p>
<p>The challenge here is coordinated releases. A new API endpoint requires frontend changes, backend implementation, infrastructure updates, and possibly model retraining. Polyrepo synthesis means Claude Code understands these dependencies and can trace the impact of changes across layers.</p>
<h3>Microservices mesh</h3>
<p>Multiple services, each in its own repository, communicating via APIs or message queues. Shared contracts (OpenAPI specs, protobuf definitions, JSON schemas) live somewhere — either in a dedicated contracts repo or duplicated across services.</p>
<p>Claude Code with access to multiple service repositories can help maintain consistency: “Update the user schema in the auth service and show me everywhere else that needs to change.”</p>
<h3>Monorepo extraction</h3>
<p>Organizations that started with a monorepo and are splitting into multiple repositories. The dependencies are already implicit in the code; the challenge is making them explicit as boundaries form.</p>
<p>This is where CLAUDE.md files become essential documentation — capturing the relationships that were previously just “everything in one place.”</p>
<h3>ML pipeline architecture</h3>
<p>Training code, inference code, model artifacts, and evaluation datasets in separate repositories. Different teams own different pieces. The data scientist’s notebook experiments eventually need to integrate with the ML engineer’s production serving code.</p>
<h2>The CLAUDE.md context mesh</h2>
<p>VS Code’s multi-root workspaces let you open multiple repositories in a single window. Claude Code reads CLAUDE.md files from each repository root. Together, these create what I call a <strong>context mesh</strong> — interconnected documentation that gives Claude Code ecosystem awareness.</p>
<p>Here’s how I structure the CLAUDE.md files in my three-repository setup:</p>
<h3>The repository ecosystem table</h3>
<p>Every CLAUDE.md starts with the same table, ensuring Claude Code always knows the landscape:</p>
<pre class="language-markdown"><code class="language-markdown">## Repository Ecosystem

| Repository | Type | Purpose | Location |
|------------|------|---------|----------|
| **ragbot** | Public | AI assistant CLI and Streamlit UI | `~/projects/my-projects/ragbot/` |
| **ragenie** | Public | Next-gen RAG platform | `~/projects/my-projects/ragenie/` |
| **ragbot-data** | Private | Shared data for both products | `~/ragbot-data/` |</code></pre>
<p>This table appears identically in all three CLAUDE.md files. When Claude Code opens any repository, it immediately understands the ecosystem.</p>
<h3>Cross-repository references</h3>
<p>Each CLAUDE.md explicitly describes relationships to siblings:</p>
<pre class="language-markdown"><code class="language-markdown">## Product relationship

- **RagBot**: Actively maintained CLI and Streamlit UI. Production-ready.
- **RaGenie**: Successor product with advanced RAG capabilities. Under development.
- Both products share ragbot-data as their data layer.
- Both products will continue to be actively developed.</code></pre>
<h3>Directory safety warnings</h3>
<p>Multi-repo development’s most common error — running git commands in the wrong directory:</p>
<pre class="language-markdown"><code class="language-markdown">## Git operations

**IMPORTANT**: Before any git commands for this repo, ensure you are in the correct directory:

```bash
cd ~/projects/my-projects/ragbot
```

Each repo in the ecosystem has its own git history. Don&#039;t run git commands from the wrong directory.</code></pre>
<p>This warning appears in every CLAUDE.md, customized with the correct path. It sounds redundant, but it’s saved me from wrong-repo commits multiple times.</p>
<h3>Architecture context</h3>
<p>Each repository’s CLAUDE.md describes its internal structure so Claude Code can navigate effectively:</p>
<pre class="language-markdown"><code class="language-markdown">## Data location

RagBot reads data from `~/ragbot-data/workspaces/`:

- **instructions/** — WHO: Identity/persona files
- **runbooks/** — HOW: Procedure guides
- **datasets/** — WHAT: Reference knowledge</code></pre>
<p>This WHO/HOW/WHAT framework organizes ragbot-data’s content. Both products understand this structure because their CLAUDE.md files reference it.</p>
<h2>A real example: the three-repository workspace</h2>
<p>Here’s how my VS Code workspace ties these repositories together. The <code>.code-workspace</code> file:</p>
<pre class="language-json"><code class="language-json">{
  &quot;folders&quot;: [
    { &quot;path&quot;: &quot;projects/my-projects/ragbot&quot;, &quot;name&quot;: &quot;RagBot (public)&quot; },
    { &quot;path&quot;: &quot;projects/my-projects/ragenie&quot;, &quot;name&quot;: &quot;RaGenie (public)&quot; },
    { &quot;path&quot;: &quot;ragbot-data&quot;, &quot;name&quot;: &quot;ragbot-data (private)&quot; }
  ],
  &quot;settings&quot;: {
    &quot;files.exclude&quot;: {
      &quot;**/.git&quot;: true,
      &quot;**/node_modules&quot;: true,
      &quot;**/__pycache__&quot;: true
    }
  }
}</code></pre>
<p>The folder names appearing in VS Code’s sidebar — “RagBot (public)”, “RaGenie (public)”, “ragbot-data (private)” — serve as constant reminders of each repository’s nature.</p>
<p>When I ask Claude Code to help with a cross-cutting change, it can trace dependencies:</p>
<blockquote>
<p>“I want to add a new workspace type to ragbot-data. What changes are needed in RagBot and RaGenie to support it?”</p>
</blockquote>
<p>Claude Code, having read all three CLAUDE.md files, understands:</p>
<ul>
<li>ragbot-data defines workspace structure in <code>workspaces/config.yaml</code></li>
<li>RagBot loads workspaces via direct file reading in <code>src/helpers.py</code></li>
<li>RaGenie watches for file changes and re-indexes into Qdrant</li>
</ul>
<p>It can provide a coherent plan spanning all three repositories.</p>
<h2>Practical workflows</h2>
<h3>Cross-repo feature development</h3>
<p>When implementing a feature that spans repositories:</p>
<ol>
<li>Start in the data/config repository — define the schema or configuration change</li>
<li>Move to the primary consumer — implement the feature using the new data structure</li>
<li>Check secondary consumers — ensure the change doesn’t break other dependents</li>
<li>Coordinate commits — meaningful commit messages that reference the cross-repo change</li>
</ol>
<p>Claude Code, having read all CLAUDE.md files, understands this sequence. Ask it “What else needs to change when I modify this schema?” and it can trace the dependencies.</p>
<h3>The “follow the data” pattern</h3>
<p>For debugging or understanding, trace data flow across repositories:</p>
<blockquote>
<p>“Show me how workspace configurations flow from ragbot-data through RagBot’s loading mechanism to the Streamlit UI”</p>
</blockquote>
<p>Claude Code with ecosystem awareness can navigate this path without you manually opening each file. It understands that ragbot-data contains the source files, RagBot’s <code>helpers.py</code> loads them, and <code>ragbot_streamlit.py</code> renders them in the interface.</p>
<h3>Coordinated releases</h3>
<p>When both products need updates:</p>
<ol>
<li>Update ragbot-data with the new content or schema</li>
<li>Update RagBot to consume the changes (bump version in <code>VERSION</code> file)</li>
<li>Update RaGenie to handle the changes (bump version, potentially update Docker compose)</li>
<li>Tag releases across repositories with related version numbers</li>
</ol>
<p>Claude Code can help maintain this coordination: “Generate release notes for this change across all three repositories.”</p>
<h2>Anti-patterns to avoid</h2>
<p><strong>Context overload</strong>: CLAUDE.md files that try to document everything overwhelm Claude Code. Focus on what’s essential for cross-repo coordination — the ecosystem table, key relationships, and directory structure.</p>
<p><strong>Conflicting instructions</strong>: Different repos with contradictory coding standards or conventions. My RagBot uses Python with type hints; RaGenie uses Python with Pydantic models plus TypeScript for the frontend. The CLAUDE.md files clarify these differences rather than pretending they don’t exist.</p>
<p><strong>Wrong directory syndrome</strong>: Running <code>git commit</code> in the wrong repository. The directory warnings help, but vigilance remains necessary. I’ve adopted the habit of always running <code>pwd</code> before any git operation.</p>
<p><strong>Stale context</strong>: CLAUDE.md files that drift from reality. When architecture changes, update the documentation. I treat CLAUDE.md as a living document — when I add a new service or change a data flow, the CLAUDE.md files get updated in the same commit.</p>
<h2>Getting started: your first polyrepo synthesis setup</h2>
<p>If you’re new to multi-repository development with Claude Code, start with these steps:</p>
<h3>1. Create a VS Code multi-root workspace</h3>
<p>File → Add Folder to Workspace for each repository you want to include. Save the workspace file (<code>.code-workspace</code>) somewhere accessible.</p>
<h3>2. Add minimal CLAUDE.md to each repository</h3>
<p>Start with just the ecosystem table:</p>
<pre class="language-markdown"><code class="language-markdown"># Claude Code Context: [repo-name]

## Repository ecosystem

| Repository | Type | Purpose | Location |
|------------|------|---------|----------|
| **[this-repo]** | [Public/Private] | [Brief purpose] | `~/path/to/[this-repo]/` |
| **[related-repo]** | [Public/Private] | [Brief purpose] | `~/path/to/[related-repo]/` |

## Related repositories

This repo works alongside:
- **[related-repo]**: [Brief description of relationship]

## Git operations

Verify directory before git commands:

```bash
cd ~/path/to/[this-repo]
```</code></pre>
<h3>3. Cross-reference the repositories</h3>
<p>Ensure each CLAUDE.md mentions its siblings. The ecosystem table should be identical across all repositories — copy-paste it to maintain consistency.</p>
<h3>4. Test with a cross-repo question</h3>
<p>Ask Claude Code something that requires understanding multiple repositories:</p>
<blockquote>
<p>“What files would need to change if I renamed the ‘workspace’ concept to ‘context’ across all repositories?”</p>
</blockquote>
<p>If Claude Code can trace the impact across repository boundaries, your context mesh is working.</p>
<h2>CLAUDE.md templates</h2>
<h3>Template 1: Hub repository (shared data/config)</h3>
<pre class="language-markdown"><code class="language-markdown"># Claude Code Context: [data-repo-name]

## Repository ecosystem

| Repository | Type | Purpose | Location |
|------------|------|---------|----------|
| **[data-repo-name]** | Private | Shared data source of truth | `~/[data-repo-name]/` |
| **[consumer-a]** | Public | Primary consumer application | `~/projects/[consumer-a]/` |
| **[consumer-b]** | Public | Secondary consumer application | `~/projects/[consumer-b]/` |

## VS Code workspace

All repositories are configured in the same VS Code workspace for unified development.

## Data organization

[Describe your data structure here — folders, file types, naming conventions]

## How consumers use this data

- **[consumer-a]**: [How it reads/uses the data]
- **[consumer-b]**: [How it reads/uses the data]

Changes here affect both consumers. Test compatibility before committing.

## Git operations

**IMPORTANT**: Before any git commands, verify your directory:

```bash
cd ~/[data-repo-name]
pwd  # Confirm location
```

Each repo has its own git history.</code></pre>
<h3>Template 2: Consumer repository (application)</h3>
<pre class="language-markdown"><code class="language-markdown"># Claude Code Context: [app-name]

## Repository ecosystem

| Repository | Type | Purpose | Location |
|------------|------|---------|----------|
| **[app-name]** | Public | [Brief description] | `~/projects/[app-name]/` |
| **[sibling-app]** | Public | [Brief description] | `~/projects/[sibling-app]/` |
| **[data-repo]** | Private | Shared data source | `~/[data-repo]/` |

## VS Code workspace

All repositories are configured in the same VS Code workspace for unified development.

## Relationship to [data-repo]

This repository consumes data from [data-repo]:
- [Describe what data is consumed]
- [Describe how it&#039;s loaded/accessed]

Changes to [data-repo] may require updates here.

## Architecture

[Brief description of key components, entry points, etc.]

## Git operations

**IMPORTANT**: Before any git commands, verify your directory:

```bash
cd ~/projects/[app-name]
pwd  # Confirm location
```

## Development notes

- When modifying shared interfaces, check [sibling-app] for compatibility
- [Other relevant development notes]</code></pre>
<h3>Template 3: Minimal starter</h3>
<pre class="language-markdown"><code class="language-markdown"># Claude Code Context: [repo-name]

## Repository ecosystem

| Repository | Type | Purpose | Location |
|------------|------|---------|----------|
| **[repo-name]** | [Public/Private] | [Brief purpose] | `~/path/to/[repo-name]/` |
| **[related-repo]** | [Public/Private] | [Brief purpose] | `~/path/to/[related-repo]/` |

## Related repositories

This repo works alongside:
- **[related-repo]**: [Brief description of relationship]

## Git operations

Verify directory before git commands:

```bash
cd ~/path/to/[repo-name]
```</code></pre>
<h2>Advanced patterns</h2>
<p>As I&#39;ve worked with polyrepo synthesis on more complex projects, I&#39;ve encountered patterns that go beyond the basic hub-and-spoke model. These lessons emerged from real production incidents and have been encoded into CLAUDE.md files to prevent recurrence.</p>
<h3>The many-to-many publishing model</h3>
<p>Not all multi-repository relationships are simple. Consider content workflows where the same article might be published to multiple destinations, managed in different local repositories based on topic rather than URL.</p>
<p><strong>The problem</strong>: AI assistants assume a simple mapping — one URL equals one local folder. They see an article at <code>https://example.com/article/</code> and assume it goes in the <code>example-site/</code> folder.</p>
<p>But real workflows are more complex:</p>
<ul>
<li>An article on <code>rajiv.com</code> might ALSO be published to <code>synthesiscoding.com</code></li>
<li>The local folder isn&#39;t determined by where the article lives, but by WHERE ELSE it will be published</li>
<li>The same WordPress site might have articles managed in different local repositories based on topic</li>
</ul>
<p><strong>Example: Dual-publishing workflow</strong></p>
<pre class="language-text"><code class="language-text">synthesis-coding-site/          # Articles dual-published to:
├── content/posts/              #   - rajiv.com (WordPress)
│   └── 2025/12/07-article/     #   - synthesiscoding.com (Cloudflare)
│       └── index.md

rajiv-site/                     # Articles published ONLY to:
├── content/posts/              #   - rajiv.com (WordPress)
│   └── 2025/12/07-other/       #   NOT dual-published elsewhere
│       └── index.md</code></pre>
<p>Both repositories contain articles that appear on <code>rajiv.com</code>. But:</p>
<ul>
<li><code>synthesis-coding-site/</code> manages articles about Synthesis Coding → dual-published</li>
<li><code>rajiv-site/</code> manages other rajiv.com articles → single destination</li>
</ul>
<p><strong>The catastrophic mistake</strong></p>
<p>When asked to &quot;fetch this article from rajiv.com,&quot; an AI assistant will:</p>
<ol>
<li>See the URL is <code>rajiv.com</code></li>
<li>Assume it goes in <code>rajiv-site/</code></li>
<li>Fetch it to the wrong location</li>
</ol>
<p>If the article is about Synthesis Coding, it now exists in the wrong repo. Publishing workflows break. Git history is polluted. The user has to manually fix the mess.</p>
<p><strong>CLAUDE.md solution: Document the publishing model</strong></p>
<p>Each repository&#39;s CLAUDE.md must explicitly document what it manages:</p>
<pre class="language-markdown"><code class="language-markdown">## What Belongs Here (Many-to-Many Publishing)

**This repository manages articles dual-published to BOTH rajiv.com AND synthesiscoding.com.**

Articles here are:
- Published to WordPress (rajiv.com) via ownwords
- Published to Cloudflare Pages (synthesiscoding.com) via git push
- Canonical URL points to rajiv.com

**Non-synthesis-coding articles that only appear on rajiv.com belong in `rajiv-site/`, not here.**

**You CANNOT determine this from the URL alone.** When in doubt, ASK the user.</code></pre>
<p><strong>The corresponding rule in the tool&#39;s CLAUDE.md</strong></p>
<p>The tool (like a content management CLI) should have generic instructions that defer to the target site:</p>
<pre class="language-markdown"><code class="language-markdown">## Fetching Articles

**When asked to fetch an article, you MUST:**

1. **ASK the user which local directory** the article should go to — never assume
2. **Check the target site&#039;s existing structure** before fetching
3. **Read the target site&#039;s CLAUDE.md** if it exists — it documents the publishing model
4. **Use the appropriate flags** based on what you learned

**Why ASK First?**
- Users may have multiple local repos for different purposes
- The source URL does NOT determine the target folder — the user&#039;s intent does
- Articles can be published to multiple sites (many-to-many publishing)
- Only the user knows their content organization</code></pre>
<h3>Open source tools in multi-repo workflows</h3>
<p>When a tool repository is open source, its CLAUDE.md must work for ALL users, not just you. This seems obvious but is consistently violated.</p>
<p><strong>What goes wrong</strong></p>
<p>A developer adds site-specific information to an open source tool&#39;s CLAUDE.md:</p>
<pre class="language-markdown"><code class="language-markdown">## Known Sites

| Site | Path |
|------|------|
| rajiv-site | `/Users/rajiv/projects/rajiv-site/` |
| synthesis-coding-site | `/Users/rajiv/projects/synthesis-coding-site/` |</code></pre>
<p>This is useless (or actively harmful) for:</p>
<ul>
<li>Other users who don&#39;t have these sites</li>
<li>Contributors trying to understand the project</li>
<li>The same developer on a different machine with a different username</li>
</ul>
<p><strong>The solution: Separation of concerns</strong></p>
<pre class="language-text"><code class="language-text">Tool repo (public, open source):
└── CLAUDE.md           # Generic: how to use the tool,
                        # general patterns, no user paths

User&#039;s site repos (may be public or private):
└── CLAUDE.md           # Specific: this site&#039;s structure,
                        # publishing model, conventions

User&#039;s global config (private):
└── ~/.claude/CLAUDE.md # Personal: cross-project standards,
                        # quality attributes, prohibited behaviors</code></pre>
<p><strong>Open source CLAUDE.md should contain:</strong></p>
<ul>
<li>How to use the tool</li>
<li>Development/contribution guidelines</li>
<li>General best practices (check structure first, ask user, etc.)</li>
<li>Project architecture</li>
<li>No hardcoded paths</li>
<li>No user-specific sites or configurations</li>
<li>No assumptions about the user&#39;s setup</li>
</ul>
<p><strong>The &quot;read target site&#39;s CLAUDE.md&quot; pattern</strong></p>
<p>Instead of encoding user-specific information, the tool&#39;s CLAUDE.md says:</p>
<pre class="language-markdown"><code class="language-markdown">**Before operating on a target site:**
1. Read the target site&#039;s CLAUDE.md if it exists
2. Check the site&#039;s existing structure
3. Ask the user if anything is unclear</code></pre>
<p>This delegates site-specific knowledge to where it belongs while keeping the tool generic. The AI reads all relevant CLAUDE.md files and combines the guidance — tool conventions from the tool repo, site-specific rules from the site repo, and personal standards from the global config.</p>
<h2>The architectural advantage</h2>
<p>I now think at the level of systems rather than files. Claude Code doesn’t just help me write code — it helps me navigate architectural relationships that would otherwise require holding too much context in my head.</p>
<p>As I wrote in my earlier piece on <a href="/articles/synthesis-engineering-with-claude-code-technical-implementation-and-workflows/">synthesis coding workflows</a>, the compounding context advantage is real. Each session builds on previous understanding. CLAUDE.md files encode institutional knowledge. The investment in setting up proper context pays dividends across every future interaction.</p>
<p>Modern software lives across multiple repositories. The engineers who master polyrepo synthesis — who can coordinate AI assistance across distributed systems while maintaining human architectural authority — will build the next generation of production software.</p>
<p>If you’ve used <a href="https://en.wikipedia.org/wiki/Vibe_coding">Vibe Coding</a> for rapid prototyping — and I do, for weekend projects and quick experiments — you know how liberating it feels to describe what you want and let the AI handle it. Polyrepo synthesis brings that same collaborative power to production systems, with the discipline required when changes span multiple repositories, teams, and deployment pipelines.</p>
<p>The CLAUDE.md context mesh is the key. Set it up once, maintain it as your architecture evolves, and watch your productivity multiply across your entire codebase.</p>
<hr>
<p><em>Rajiv Pant is President of <a href="https://www.flatiron.software/">Flatiron Software</a> and <a href="https://www.snapshot.reviews/">Snapshot AI</a>, where he leads organizational growth and AI innovation. He is former Chief Product &amp; Technology Officer at The Wall Street Journal, The New York Times, and Hearst Magazines. Earlier in his career, he headed technology for Conde Nast’s brands including Reddit. Rajiv has been working with AI in software engineering since the early days of natural language processing and was an early investor and advisor to AI search company <a href="https://you.com/">You.com</a>. He coined the terms &quot;synthesis engineering&quot; and &quot;<a href="https://synthesiscoding.com/">synthesis coding</a>&quot; to describe the systematic integration of human expertise with AI capabilities in professional software development. Connect with him on <a href="https://www.linkedin.com/in/rajivpant/">LinkedIn</a> or read more at <a href="https://rajiv.com/">rajiv.com</a>.</em></p>

            </div>

            <div class="article-tags">
                <div class="article-tags-label">Tags</div>
                <a href="/articles/tag/artificial-intelligence/" class="tag">artificial intelligence</a><a href="/articles/tag/claude-code/" class="tag">Claude Code</a><a href="/articles/tag/ctobook/" class="tag">ctobook</a><a href="/articles/tag/programming/" class="tag">programming</a><a href="/articles/tag/software-engineering/" class="tag">software engineering</a><a href="/articles/tag/synthesis-coding/" class="tag">synthesis coding</a><a href="/articles/tag/synthesis-engineering/" class="tag">synthesis engineering</a><a href="/articles/tag/vibe-coding/" class="tag">vibe coding</a>
            </div>

            <p class="canonical-notice">
                Originally published on <a href="https://rajiv.com/blog/2025/11/30/polyrepo-synthesis-synthesis-coding-across-multiple-repositories-with-claude-code-in-visual-studio-code/">rajiv.com</a>
            </p>

            <section class="related-articles">
    <h2>Related Articles</h2>
    <div class="related-grid">
      <a href="/articles/synthesis-engineering-with-claude-code-technical-implementation-and-workflows/" class="related-card">
        <span class="related-title">Synthesis Coding with Claude Code: Technical Implementation and Workflows</span>
        <span class="related-meta">14 min read</span>
      </a>
      <a href="/articles/building-ownwords-a-synthesis-coding-case-study/" class="related-card">
        <span class="related-title">Building ownwords: A Synthesis Coding Case Study</span>
        <span class="related-meta">10 min read</span>
      </a>
      <a href="/articles/why-synthesis-coding-still-writes-code-in-the-age-of-llms/" class="related-card">
        <span class="related-title">Why Synthesis Coding Still Writes Code in the Age of LLMs</span>
        <span class="related-meta">15 min read</span>
      </a>
    </div>
  </section>
        </article>
    </main>

    <footer>
        <p class="cc0">The terms "Synthesis Coding" and "Synthesis Engineering," along with the associated logo and visual identity, are released under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0 Universal</a> (public domain). No permission required. No attribution needed. Use freely. The logo was hand-crafted by a human artist.</p>
        <p><a href="/">← Back to Synthesis Coding</a></p>
        <p class="built-with">
            Built with <a href="https://github.com/rajivpant/ownwords">ownwords</a>,
            <a href="https://claude.ai/claude-code">Claude Code</a>,
            <a href="https://pages.cloudflare.com/">Cloudflare</a> &amp; friends ·
            <a href="/colophon/">Colophon</a>
        </p>
    </footer>

    <!-- Prism.js core and language support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <!-- Prism.js plugins -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

    <!-- Auto-detect language and initialize Prism for all code blocks -->
    <script>
    (function() {
        // Auto-detect language based on content patterns
        function detectLanguage(code) {
            const text = code.textContent || '';
            const firstLine = text.trim().split('\n')[0];

            // Shell/bash patterns
            if (/^\$\s/.test(firstLine) || /^claude\s/.test(firstLine) ||
                /^(cd|ls|npm|git|mkdir|rm|cp|mv|cat|echo|export|source)\s/.test(firstLine) ||
                /^#!\/bin\/(ba)?sh/.test(firstLine)) {
                return 'bash';
            }
            // Python patterns
            if (/^(import |from |def |class |if __name__|print\()/.test(firstLine) ||
                /^\s*(import |from )/.test(text)) {
                return 'python';
            }
            // JavaScript/TypeScript patterns
            if (/^(const |let |var |function |import |export |async |await )/.test(firstLine) ||
                /^(import \{|export \{|module\.exports)/.test(text)) {
                return 'javascript';
            }
            // JSON patterns
            if (/^\s*[\{\[]/.test(firstLine) && /[\}\]]\s*$/.test(text.trim())) {
                return 'json';
            }
            // YAML patterns
            if (/^[a-zA-Z_-]+:\s/.test(firstLine)) {
                return 'yaml';
            }
            // SQL patterns
            if (/^(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)\s/i.test(firstLine)) {
                return 'sql';
            }
            // Default to bash for command-like content
            if (/^\w+\s+["']/.test(firstLine) || /^[\w-]+\s+--/.test(firstLine)) {
                return 'bash';
            }
            return 'bash'; // Default fallback
        }

        // Process all code blocks
        document.querySelectorAll('pre').forEach(function(pre) {
            var code = pre.querySelector('code');
            if (!code) {
                // Wrap content in code element if missing
                code = document.createElement('code');
                code.innerHTML = pre.innerHTML;
                pre.innerHTML = '';
                pre.appendChild(code);
            }

            // Check if language class already exists
            var hasLang = pre.className.match(/language-(\w+)/) ||
                          code.className.match(/language-(\w+)/);

            if (!hasLang) {
                // Auto-detect and apply language
                var lang = detectLanguage(code);
                pre.className = (pre.className + ' language-' + lang).trim();
                code.className = (code.className + ' language-' + lang).trim();
            } else {
                // Ensure both pre and code have the language class
                var langClass = 'language-' + hasLang[1];
                if (!pre.className.includes(langClass)) {
                    pre.className = (pre.className + ' ' + langClass).trim();
                }
                if (!code.className.includes(langClass)) {
                    code.className = (code.className + ' ' + langClass).trim();
                }
            }
        });

        // Re-highlight all code blocks with Prism
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    })();
    </script>
</body>
</html>
